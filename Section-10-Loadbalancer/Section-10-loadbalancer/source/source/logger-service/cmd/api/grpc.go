package main

// go get google.golang.org/grpc before starting excercise

/* this is going to be server which will receive the requests */

import (
	"context"
	"fmt"
	"log"
	"log-service/data"
	"log-service/logs"
	"net"

	"google.golang.org/grpc"
)

// create a type of LogServer with two fields logs.UnimplementedLogServiceServer this field or server is required for every service we write over GRPC. Bascially it will ensure backward compatilibility
// Also lets have Models data.Models second field, this will have access for necessary methods to write on Mongo
type LogServer struct {
	logs.UnimplementedLogServiceServer
	Models data.Models
}

// Lets write a func method WriteLog to LogServer type l, needs context and also request req pointer to logs package LogRequest which is generated code now
// It returns generated log response and potential error
func (l *LogServer) WriteLog(ctx context.Context, req *logs.LogRequest) (*logs.LogResponse, error) {
	// continue using generated code, we try to get some kind of input for logs request req which is second parameter of WriteLog func
	//It has generated nice func named GetLogEntry for us that gets our input
	//This just contains input.Name and input.Data specified in protobuff file
	input := req.GetLogEntry()

	// write the log
	logEntry := data.LogEntry{
		Name: input.Name,
		Data: input.Data,
	}
	//use the Models field part of LogServer struct to write to MongoDB
	err := l.Models.LogEntry.Insert(logEntry)
	//checking for error, we need to make a response res = &logs.LogResponse{Result: "failed"} and return result failed and error
	if err != nil {
		res := &logs.LogResponse{Result: "failed"}
		return res, err
	}

	// return response if successful.we need to make a response res = &logs.LogResponse{Result: "logged!"} and err != nil
	//Next we need to Listen on GRPC server
	res := &logs.LogResponse{Result: "logged!"}
	return res, nil
}

// Next we need to Listen on GRPC server. write the func gRPC listen
func (app *Config) gRPCListen() {
	//net package Listen on tcp, GRPC port
	lis, err := net.Listen("tcp", fmt.Sprintf(":%s", gRpcPort))
	if err != nil {
		log.Fatalf("Failed to listen for gRPC: %v", err)
	}
	//If we pass above lines we can listen for grpc connections
	//Create a var s for server amd grpc package newserver
	s := grpc.NewServer()
	//register the server using autogenerated code from logs package calling RegisterLogServiceServer
	//This RegisterLogServiceServer func requires grpc server and also requires referenece to logserver which type created in protofile which requires Models has app.models
	logs.RegisterLogServiceServer(s, &LogServer{Models: app.Models})

	log.Printf("gRPC Server started on port %s", gRpcPort)
	//s.server(listener) will start and serve grpc now
	if err := s.Serve(lis); err != nil {
		log.Fatalf("Failed to listen for gRPC: %v", err)
	}
}
